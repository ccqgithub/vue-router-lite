{"version":3,"file":"router.common.js","sources":["../src/util/utils.js","../src/component/Router.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.js","../src/component/MemoryRouter.vue","../src/component/HashRouter.vue","../src/component/BrowserRouter.vue","../src/util/createStaticHistory.js","../src/component/StaticRouter.vue","../src/util/matchPath.js","../src/component/Route.vue","../src/component/Prompt.vue","../src/util/generatePath.js","../src/component/Redirect.vue","../src/component/Tag.vue","../src/component/RouterLink.vue","../src/component/RouterRef.vue","../src/component/MatchFirst.vue"],"sourcesContent":["import { createLocation } from \"history\";\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(`[vue-router-lite] ${message}`);\n  }\n}\n\nexport function warn(condition, message) {\n  if (process.env.NODE_ENV !== 'production' && !condition) {\n    typeof console !== 'undefined' && console.warn(`[vue-router-lite] ${message}`);\n  }\n}\n\nexport function isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\n// copyJson\nexport function copyJson(data) {\n  return JSON.parse(JSON.stringify(data));\n}\n\n// \nexport const resolveToLocation = (to, currentLocation) =>\n  typeof to === \"function\" ? to(currentLocation) : to;\n\n// \nexport const normalizeToLocation = (to, currentLocation) => {\n  return typeof to === \"string\"\n    ? createLocation(to, null, null, currentLocation)\n    : to;\n};\n\nexport const guardEvent = (e) => {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) return;\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) return;\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    const target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) return;\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true;\n}\n\nexport function isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n\nexport function isNotTextNode(c) { \n  return c.tag || isAsyncPlaceholder(c); \n};","<script>\nimport { assert, isNotTextNode } from '../util/utils';\n\nconst Router = {\n  name: 'router',\n\n  props: {\n    // history control\n    history: {\n      type: Object,\n      required: true\n    },\n    // name for debug\n    name: {\n      type: String,\n      default: 'router'\n    }\n  },\n\n  provide() {\n    return {\n      router: this.router,\n      route: this.route\n    };\n  },\n\n  data() {\n    return {\n      // add provide's properties in data, to make provide reactivity \n      router: {\n        history: this.history\n      },\n      // add provide's properties in data, to make provide reactivity \n      route: {\n        location: this.history.location,\n        match: this.computeMatch(this.history.location.pathname)\n      }\n    };\n  },\n\n  created() {\n    const { history } = this;\n    this.unlisten = history.listen(() => {\n      this.route.location = history.location;\n      this.route.match = this.computeMatch(history.location.pathname);\n    });\n  },\n\n  befreDestory() {\n    this.unlisten();\n  },\n\n  watch: {\n    history(val, oldVal) {\n      assert(false, `You cannot change <router>\\'s history!`);\n    }\n  },\n  methods: {\n    computeMatch(pathname) {\n      return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n    }\n  },\n  render(createElement) {\n    let children = this.$scopedSlots.default({\n      history: this.history,\n      location: this.route.location,\n      match: this.route.match\n    });\n\n    children = children.filter(isNotTextNode);\n  \n    assert(\n      children.length === 1, \n      `<${this.name}> must only be used on a single child element.`\n    );\n\n    return children[0];\n  }\n}\n\nexport default Router;\n</script>","'use strict';\n\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n/* server only */\n, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  } // Vue.extend constructor export interop.\n\n\n  var options = typeof script === 'function' ? script.options : script; // render functions\n\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true; // functional template\n\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  } // scopedId\n\n\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n\n  var hook;\n\n  if (moduleIdentifier) {\n    // server build\n    hook = function hook(context) {\n      // 2.3 injection\n      context = context || // cached call\n      this.$vnode && this.$vnode.ssrContext || // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      } // inject component styles\n\n\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      } // register component module identifier for async chunk inference\n\n\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    }; // used by ssr in case component is cached and beforeCreate\n    // never gets called\n\n\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function () {\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      var originalRender = options.render;\n\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n\n  return script;\n}\n\nmodule.exports = normalizeComponent;\n//# sourceMappingURL=normalize-component.js.map\n","<template>\n  <router :history=\"history\" name=\"memory-router\" v-slot=\"routerProps\">\n    <slot v-bind=\"routerProps\"/>\n  </router>\n</template>\n\n<script>\nimport createMemoryHistory from '../util/createMemoryHistory';\nimport { assert } from '../util/utils';\nimport Router from './Router.vue';\n\nconst MemoryRouter = {\n  name: 'memory-router',\n\n  components: {\n    Router\n  },\n\n  props: {\n    initialEntries: {\n      type: Array,\n      default: () => ['/']\n    },\n    initialIndex: {\n      type: Number,\n      default: 0\n    },\n    keyLength: {\n      type: Number,\n      default: 6\n    },\n    getUserConfirmation: {\n      type: Function\n    }\n  },\n\n  data() {\n    let history = createMemoryHistory({\n      initialEntries: this.initialEntries,\n      initialIndex: this.initialIndex,\n      keyLength: this.keyLength,\n      getUserConfirmation: this.getUserConfirmation\n    });\n\n    return {\n      history\n    };\n  }\n}\n\nexport default MemoryRouter;\n</script>","<template>\n  <router :history=\"history\" name=\"hash-router\" v-slot=\"routerProps\">\n    <slot v-bind=\"routerProps\"/>\n  </router>\n</template>\n\n<script>\nimport createHashHistory from '../util/createHashHistory';\nimport { assert } from '../util/utils';\nimport Router from './Router.vue';\n\nconst HashRouter = {\n  name: 'hash-router',\n\n  components: {\n    Router\n  },\n\n  props: {\n    basename: {\n      type: String,\n      default: ''\n    },\n    hashType: {\n      validator(value) {\n        return [\"hashbang\", \"noslash\", \"slash\"].indexOf(value) !== -1;\n      }\n    },\n    getUserConfirmation: {\n      type: Function,\n      default(message, callback) {\n        callback(window.confirm(message));\n      }\n    }\n  },\n\n  data() {\n    let history = createHashHistory({\n      basename: this.basename,\n      hashType: this.hashType,\n      getUserConfirmation: this.getUserConfirmation\n    });\n\n    return {\n      history\n    };\n  }\n}\n\nexport default HashRouter;\n</script>","<template>\n  <router :history=\"history\" name=\"browser-router\" v-slot=\"routerProps\">\n    <slot v-bind=\"routerProps\"/>\n  </router>\n</template>\n\n<script>\nimport createBrowserHistory from '../util/createBrowserHistory';\nimport { assert } from '../util/utils';\nimport Router from './Router.vue';\n\nconst BrowserRouter = {\n  name: 'browser-router',\n\n  components: {\n    Router\n  },\n\n  props: {\n    basename: {\n      type: String,\n      default: ''\n    },\n    forceRefresh: {\n      type: Boolean,\n      default: false\n    },\n    keyLength: {\n      type: Number,\n      default: 6\n    },\n    getUserConfirmation: {\n      type: Function,\n      default(message, callback) {\n        callback(window.confirm(message));\n      }\n    }\n  },\n\n  data() {\n    let history = createBrowserHistory({\n      basename: this.basename,\n      forceRefresh: this.forceRefresh,\n      keyLength: this.keyLength,\n      getUserConfirmation: this.getUserConfirmation\n    });\n\n    return {\n      history\n    };\n  }\n}\n\nexport default BrowserRouter;\n</script>","import { createLocation, createPath } from \"history\";\n\nconst addLeadingSlash = (path) => {\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\n};\n\nconst removeTailSlash = (path) => {\n  return path.replace(/\\/+$/, '');\n}\n\nconst addBasename = (basename, location) => {\n  if (!basename) return location;\n\n  return {\n    ...location,\n    pathname: removeTailSlash(addLeadingSlash(basename)) + addLeadingSlash(location.pathname)\n  };\n};\n\nconst stripBasename = (basename, location) => {\n  if (!basename) return location;\n\n  const base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return {\n    ...location,\n    pathname: addLeadingSlash(location.pathname.substr(base.length))\n  };\n};\n\nconst createURL = (location) =>\n  typeof location === \"string\" ? location : createPath(location);\n\nconst staticHandler = (methodName) => () => {\n  throw new Error(`You cannot ${methodName} with <StaticRouter>`);\n};\n\nconst noop = () => {};\n\nfunction createStaticHistory({ basename = '', context = {}, location = '/' }) {\n  const history = {\n    isStatic: true,\n    context: context,\n    action: \"POP\",\n    location: stripBasename(basename, createLocation(location)),\n    go: staticHandler(\"go\"),\n    goBack: staticHandler(\"goBack\"),\n    goForward: staticHandler(\"goForward\"),\n    createHref: (location) => {\n      return addLeadingSlash(removeTailSlash(basename) + createURL(location))\n    },\n    push: (location) => {\n      context.action = \"PUSH\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    },\n    replace: (location) => {\n      context.action = \"REPLACE\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, \n    listen: () => noop,\n    block: () => noop\n  };\n\n  return history;\n}\n\nexport default createStaticHistory;","<template>\n  <router :history=\"history\" name=\"static-router\" v-slot=\"routerProps\">\n    <slot v-bind=\"routerProps\"/>\n  </router>\n</template>\n\n<script>\nimport { assert } from '../util/utils';\nimport createStaticHistory from \"../util/createStaticHistory\";\nimport Router from \"./Router.vue\";\n\nconst StaticRouter = {\n  name: 'static-router',\n\n  components: {\n    Router\n  },\n  \n  props: {\n    basename: {\n      type: String,\n      default: ''\n    },\n    context: {\n      type: Object,\n      default: () => {}\n    },\n    location: {\n      type: [String, Object],\n      default: '/'\n    }\n  },\n\n  data() {\n    const history = createStaticHistory({ \n      basename: this.basename,\n      context: this.context,\n      location: this.location\n    });\n\n    return {\n      history\n    };\n  }\n}\n\nexport default StaticRouter;\n</script>","/**\n * copy from:\n * https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/matchPath.js\n */\n\nimport pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) return pathCache[path];\n\n  const keys = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = { regexp, keys };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\n/**\n * matching a URL pathname to a path.\n * pathname: current locations's pathname\n */\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\") options = { path: options };\n\n  const { path, exact = true, strict = false, sensitive = true } = options;\n\n  const paths = [].concat(path);\n\n  return paths.reduce((matched, path) => {\n    if (matched) return matched;\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport default matchPath;","<script>\nimport { assert, isNotTextNode } from '../util/utils';\nimport matchPath from '../util/matchPath';\n\nconst Route = {\n  name: 'route',\n  \n  props: {\n    path: {\n      type: [String, Array],\n      default: ''\n    },\n    exact: {\n      type: Boolean,\n      default: false\n    },\n    strict: {\n      type: Boolean,\n      default: false\n    },\n    sensitive: {\n      type: Boolean,\n      default: true\n    },\n    forceRender: {\n      type: Boolean,\n      default: false\n    },\n    location: {\n      type: Object\n    }\n  },\n\n  inject: ['router', 'route'],\n\n  provide() {\n    return {\n      route: this.route\n    }\n  },\n\n  data() {\n    return {\n      isActive: true,\n      // add provide's properties in data, to make provide reactivity \n      computedRoute: {\n        location: this.computeLocation(),\n        match: this.computeMatch()\n      }\n    }\n  },\n\n  watch: {\n    route: {\n      handler() {\n        if (!this.isActive) return;\n        this.computedRoute.location = this.computeLocation();\n        this.computedRoute.match = this.computeMatch();\n      },\n      deep: true\n    }\n  },\n\n  created() {\n    assert(\n      this.router,\n      `You should not use <route> outside a <router>.`\n    );\n\n    this.cacheMatch = null;\n    // use for keepalive\n    this.cache = Object.create(null);\n  },\n\n  destroyed () {\n    this.clearCache();\n  },\n\n  beforeUpdate() {\n    assert(\n      this.router,\n      `You should not use <route> outside a <router>.`\n    );\n  },\n\n  activated() {\n    this.isActive = true;\n    this.computedRoute.location = this.computeLocation();\n    this.computedRoute.match = this.computeMatch();\n  },\n\n  deactivated() {\n    this.isActive = false;\n  },\n\n  methods: {\n    computeLocation() {\n      return this.location || this.route.location;\n    },\n    computeMatch() {\n      const computedLocation = this.computeLocation();\n      const { path, strict, exact, sensitive, route } = this;\n      const pathname = computedLocation.pathname;\n      const match = path ? \n        matchPath(\n          pathname,\n          { path, strict, exact, sensitive }\n        ) : route.match;\n\n      // cache\n      if (!this.cacheMatch || !match) {\n        this.cacheMatch = match;\n      } else {\n        Object.keys(match).forEach(key => {\n          this.cacheMatch[key] = match[key];\n        })\n      }\n\n      return this.cacheMatch;\n    },\n    clearCache() {\n      for (let key in this.cache) {\n        this.cache[key].componentInstance.$destroy();\n        this.cache[key] = null;\n      }\n    }\n  },\n\n  render(createElement) {\n    const { router, computedRoute, forceRender, $scopedSlots, name, cache } = this;\n    const { history } = router;\n    const { match, location } = computedRoute;\n    const isKeepAlive = this.$vnode.data.keepAlive;\n\n    // no keep alive\n    if (!isKeepAlive) {\n      this.clearCache();\n    }\n\n    if (!match && !forceRender) return null;\n\n    let children = $scopedSlots.default({ match, history, location });\n    children = (children || []).filter(isNotTextNode);\n\n    if (!children.length) return null;\n\n    assert(\n      children.length === 1, \n      `<${name}> can only be used on a single child element.`\n    );\n    \n    const vnode = children[0];\n    const componentOptions = vnode && vnode.componentOptions;\n\n    // is keepAlive and is component\n    if (isKeepAlive && componentOptions) {\n      const key = vnode.key == null\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n      } else {\n        cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    \n    return vnode;\n  }\n};\n\nexport default Route;\n</script>\n","<script>\nimport { assert } from '../util/utils';\n\nconst Prompt = {\n  name: 'prompt',\n\n  props: {\n    when: {\n      type: Boolean,\n      default: true\n    },\n    message: {\n      type: [Function, String],\n      required: true\n    }\n  },\n\n  inject: ['router', 'route'],\n\n  created() {\n    assert(\n      this.router,\n      'You should not use <prompt> outside a <router>'\n    );\n\n    this.lastMessage = null;\n    this.unblock = null;\n  },\n\n  beforeUpdate() {\n    assert(\n      this.router,\n      'You should not use <prompt> outside a <router>'\n    );\n  },\n\n  mounted() {\n    if(this.when) this.block(); \n  },\n\n  watch: {\n    when(val, oldVal) {\n      if (!val) {\n        if (this.unblock) this.unblock()\n      } else {\n        this.block();\n      }\n    }\n  },\n\n  methods: {\n    block() {\n      let { message, lastMessage } = this;\n\n      if (!this.unblock) {\n        this.unblock = this.router.history.block(message);\n      } else if (message !== lastMessage) {\n        this.unblock();\n        this.unblock = this.router.history.block(message);\n      }\n\n      // last message\n      this.lastMessage = message;\n    }\n  },\n\n  beforeDestroy() {\n    if (this.unblock) this.unblock();\n  },\n\n  render() {\n    return null;\n  }\n}\n\nexport default Prompt;\n</script>","/**\n * copy from:\n * https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/generatePath.js\n */\n\nimport pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path) {\n  if (cache[path]) return cache[path];\n\n  const generator = pathToRegexp.compile(path);\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = generator;\n    cacheCount++;\n  }\n\n  return generator;\n}\n\n/**\n * generating a URL pathname from a path and parameters.\n */\nfunction generatePath(path = \"/\", params = {}, options = {}) {\n  return path === \"/\" ? path : compilePath(path)(params, options);\n}\n\nexport default generatePath;","<script>\nimport { createLocation, locationsAreEqual } from \"history\";\nimport { assert } from '../util/utils';\nimport generatePath from \"../util/generatePath\";\n\nconst Redirect = {\n  name: 'redirect',\n\n  props: {\n    // to path\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    // wheather push\n    push: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  inject: ['router', 'route'],\n\n  created() {\n    assert(\n      this.router,\n      'You must not use <redirect> outside a <router>.'\n    );\n\n    // static router\n    if (this.isStatic()) this.perform();\n  },\n\n  mounted() {\n    // not static router\n    if (!this.isStatic()) this.perform();\n  },\n\n  beforeUpdate() {\n    assert(\n      this.router,\n      'You must not use <redirect> outside a <router>.'\n    );\n\n    const to = this.computeTo();\n\n    // already redirect\n    if (locationsAreEqual(this.lastTo, to)) {\n      return;\n    }\n\n    this.perform();\n  },\n\n  methods: {\n    // if static router\n    isStatic() {\n      return this.router && this.router.history.isStatic;\n    },\n\n    // to location\n    computeTo() {\n      const { match } = this.route;\n      // to\n      let p = this.to;\n      // route\n      if (match) {\n        if (typeof this.to === 'string') {\n          // to is string\n          p = generatePath(this.to, match.params);\n        } else {\n          // to is object\n          p = {\n            ...this.to,\n            pathname: generatePath(\n              this.to.pathname,\n              match.params\n            )\n          };\n        }\n      }\n\n      // to\n      const to = createLocation(p); \n\n      return to;\n    },\n\n    perform() {\n      const { history } = this.router;\n\n      // history method\n      const method = this.push\n        ? history.push\n        : history.replace;\n\n      const to = this.computeTo();\n\n      // redirect\n      this.lastTo = to;\n      method(to);\n    }\n  },\n\n  render() {\n    return null;\n  }\n}\n\nexport default Redirect;\n</script>","<script>\nexport default {\n  name: 'tag',\n  functional: true,\n  props: {\n    tag: String\n  },\n  render(createElement, context) {\n    return createElement(context.props.tag || 'div', context.data, context.children);\n  }\n}\n</script>\n","<template>\n  <tag\n    v-bind=\"$attrs\"\n    :tag=\"tag\"\n    :href=\"href\"\n    :class=\"classNames\"\n    @[event]=\"handleClick($event)\"\n  >\n    <slot \n      :href=\"href\" \n      :match=\"match\" \n      :history=\"router.history\" \n      :location=\"router.history.location\" \n    />\n  </tag>\n</template>\n\n<script>\nimport { \n  assert, \n  resolveToLocation, \n  normalizeToLocation, \n  guardEvent \n} from '../util/utils';\nimport matchPath from '../util/matchPath';\nimport Tag from './Tag.vue';\n\nconst RouterLink = {\n  name: 'router-link',\n  \n  components: {\n    Tag\n  },\n\n  props: {\n    // to path\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    // replace or push\n    replace: {\n      type: Boolean,\n      default: false\n    },\n    // tag\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    // user to check active\n    exact: {\n      type: Boolean,\n      default: false\n    },\n    // user to check active\n    strict: {\n      type: Boolean,\n      default: false\n    },\n    // user to check active\n    sensitive: {\n      type: Boolean,\n      default: true\n    },\n    // active class name\n    activeClass: {\n      type: String,\n      default: 'router-link-active'\n    },\n    // active class name\n    exactActiveClass: {\n      type: String,\n      default: 'router-link-exact-active'\n    },\n    // navitage event\n    event: {\n      type: String,\n      default: 'click'\n    },\n    // location\n    location: {\n      type: Object\n    }\n  },\n\n  inject: ['router', 'route'],\n\n  computed: {\n    // current location\n    currentLocation() {\n      const currentLocation = this.location || this.route.location;\n      return currentLocation;\n    },\n    // to location\n    toLocation() {\n      const toLocation = normalizeToLocation(\n        resolveToLocation(this.to, this.currentLocation),\n        this.currentLocation\n      );\n      return toLocation;\n    },\n    // link href\n    href() {\n      const { history } = this.router;\n      const href = this.toLocation ? history.createHref(this.toLocation) : '';\n\n      return href;\n    },\n    // path match with current location\n    match() {\n      const { to, exact, strict, sensitive } = this;\n      const { pathname: pathToMatch } = this.currentLocation;\n      const { pathname: path } = this.toLocation;\n      // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n      const escapedPath =\n        path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n      const match = escapedPath\n        ? matchPath(pathToMatch, { path: escapedPath, exact, strict, sensitive })\n        : null;\n\n      return match;\n    },\n    classNames() {\n      let classNames = '';\n      if (!this.match) return classNames;\n\n      classNames += ` ${this.activeClass}`;\n      if (this.match.exact) classNames += ` ${this.exactActiveClass}`;\n      \n      return classNames;\n    }\n  },\n\n  methods: {\n    handleClick(event) {\n      this.$emit('click', event);\n\n      if (!guardEvent(event)) return;\n\n      const { history } = this.router;\n      const { replace, to } = this;\n      const loc = resolveToLocation(to, this.currentLocation);\n\n      if (replace) {\n        history.replace(loc);\n      } else {\n        history.push(loc);\n      }\n    }\n  },\n\n  created() {\n    assert(\n      this.router,\n      'You should not use <router-link> outside a <router>'\n    );\n  },\n\n  beforeUpdate() {\n    assert(\n      this.router,\n      'You should not use <router-link> outside a <router>'\n    );\n  }\n}\n\nexport default RouterLink;\n</script>","<script>\nexport default {\n  name: 'router-ref',\n  inject: ['router', 'route'],\n  data() {\n    return {\n      history: this.router.history,\n      location: this.route.location,\n      match: this.route.match\n    };\n  },\n  render() {\n    return null;\n  }\n}\n</script>\n","<script>\nimport { assert, isNotTextNode } from '../util/utils';\nimport matchPath from \"../util/matchPath\";\n\nexport default {\n  name: 'match-first',\n  functional: true,\n  props: {\n    location: Object\n  },\n  inject: ['router', 'route'],\n  render(createElement, context) {\n    const { router, route } = context.injections;\n\n    assert(\n      router, \n      `You should not use <match-first> outside a <router>'`\n    );\n\n    let vnodeKey = '';\n    const location = context.props.location || route.location;\n    const children = context.slots().default.filter(isNotTextNode);\n    const vnode = children.find((vnode) => {\n      if (!vnode.componentOptions) return false;\n      const propsData = vnode.componentOptions.propsData || {};\n      const { path = '', exact = false, strict = false, sensitive = true, key = '' } = propsData;\n      vnodeKey = key || `path-${path}--exact-${exact}--strict-${strict}--sensitive=${sensitive}`;\n      // no path on route\n      if (!path) return true;\n      const match = matchPath(location.pathname, { path, exact, strict, sensitive });\n      return !!match;\n    });\n\n    // key\n    if (vnode) vnode.key = vnodeKey;\n\n    return vnode;\n  }\n}\n</script>\n"],"names":["assert","condition","message","Error","resolveToLocation","to","currentLocation","normalizeToLocation","createLocation","guardEvent","e","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","undefined","currentTarget","getAttribute","target","test","preventDefault","isAsyncPlaceholder","node","isComment","asyncFactory","isNotTextNode","c","tag","addLeadingSlash","path","charAt","removeTailSlash","replace","addBasename","basename","location","pathname","stripBasename","base","indexOf","substr","length","createURL","createPath","staticHandler","methodName","noop","createStaticHistory","context","history","isStatic","action","go","goBack","goForward","createHref","push","url","listen","block","cache","cacheLimit","cacheCount","compilePath","options","cacheKey","end","strict","sensitive","pathCache","keys","regexp","pathToRegexp","result","matchPath","exact","paths","concat","reduce","matched","match","exec","values","isExact","params","memo","key","index","name","generator","compile","generatePath"],"mappings":"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"}