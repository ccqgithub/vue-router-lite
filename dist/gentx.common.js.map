{"version":3,"file":"gentx.common.js","sources":["../src/util/utils.js","../src/util/Single.js","../src/component/Router.vue","../src/component/MemoryRouter.vue","../src/component/HashRouter.vue","../src/component/BrowserRouter.vue","../src/component/StaticRouter.vue","../src/util/matchPath.js","../src/component/Route.vue","../src/util/empty.js","../src/component/Prompt.vue","../src/util/generatePath.js","../src/component/Redirect.vue","../src/util/Tag.js","../src/component/Link.vue","../src/component/NavLink.vue","../src/util/Switch.js","../src/util/withRouter.js"],"sourcesContent":["// warning\nexport function warning(message) {\n  if (!console || !console.warn) return;\n  console.warn(message);\n}\n\n// copyJson\nexport function copyJson(data) {\n  return JSON.parse(JSON.stringify(data));\n}","import { warning } from './utils';\n\n/**\n * render the first existent child or empty\n */\nconst Single = {\n  functional: true,\n  render(h, context) {\n    if (!context.children.length) return null;\n\n    if (context.children > 1) {\n      warning(`The component ${context.props.name || 'Single'} should have only one child!`);\n    }\n\n    return context.children[0];\n  }\n}\n\nexport default Single;","<template>\n  <single>\n    <slot></slot>\n  </single>\n</template>\n\n<script>\nimport { warning, copyJson } from '../util/utils';\nimport Single from '../util/Single';\n\nconst Router = {\n  components: {\n    Single\n  },\n\n  props: {\n    history: {\n      type: Object,\n      required: true\n    }\n  },\n\n  provide() {\n    return {\n      router: {\n        history: this.history,\n        route: this.route\n      }\n    }\n  },\n\n  data() {\n    return {\n      route: this.computeRoute(this.history)\n    }\n  },\n\n  beforeMount() {\n    const { history } = this;\n    this.unlisten = history.listen(() => {\n      this.route = this.computeRoute(history);\n    });\n  },\n\n  befreDestory() {\n    this.unlisten();\n  },\n\n  watch: {\n    history(val, oldVal) {\n      warning('You cannot change <Router history>');\n    }\n  },\n\n  methods: {\n    computeRoute(history) {\n      let pathname = history.location.pathname;\n      return {\n        location: copyJson(history.location),\n        match: {\n          path: \"/\",\n          url: \"/\",\n          params: {},\n          isExact: pathname === \"/\"\n        }\n      }\n    }\n  }\n}\n\nexport default Router;\n</script>","<template>\n  <router :history=\"childHistory\">\n    <slot></slot>\n  </router>\n</template>\n\n<script>\nimport { createMemoryHistory as createHistory } from \"history\";\nimport { warning } from '../util/utils';\nimport Router from './Router.vue';\n\nconst MemoryRouter = {\n  components: {\n    Router\n  },\n\n  props: {\n    // just use to check if user pass history\n    history: {\n      validator: function (value) {\n        return true;\n      }\n    },\n\n    initialEntries: Array,\n    initialIndex: Number,\n    getUserConfirmation: Function,\n    keyLength: Number\n  },\n\n  data() {\n    let history = createHistory({\n      initialEntries: this.initialEntries,\n      initialIndex: this.initialIndex,\n      getUserConfirmation: this.getUserConfirmation,\n      keyLength: this.keyLength\n    });\n\n    return {\n      childHistory: history\n    }\n  },\n\n  beforeMount() {\n    if (this.history) {\n      warning(\n        '<MemoryRouter> ignores the history prop. To use a custom history, ' +\n        'use `import { Router }` instead of `import { MemoryRouter as Router }`.'\n      )\n    }\n  }\n}\n\nexport default MemoryRouter;\n</script>","<template>\n  <router :history=\"childHistory\">\n    <slot></slot>\n  </router>\n</template>\n\n<script>\nimport { createHashHistory as createHistory } from \"history\";\nimport { warning } from '../util/utils';\nimport Router from './Router.vue';\n\nconst HashRouter = {\n  components: {\n    Router\n  },\n\n  props: {\n    history: Object,\n    basename: String,\n    hashType: {\n      validator: function(value) {\n        return [\"hashbang\", \"noslash\", \"slash\"].indexOf(value) !== -1\n      }\n    },\n    getUserConfirmation: Function\n  },\n\n  data() {\n    let history = this.history;\n    if (!history) {\n      history = createHistory({\n        basename: this.basename,\n        hashType: this.hashType,\n        getUserConfirmation: this.getUserConfirmation\n      });\n    }\n\n    return {\n      childHistory: history\n    }\n  }\n}\n\nexport default HashRouter;\n</script>","<template>\n  <router :history=\"childHistory\">\n    <slot></slot>\n  </router>\n</template>\n\n<script>\nimport { createBrowserHistory as createHistory } from \"history\";\nimport { warning } from '../util/utils';\nimport Router from './Router.vue';\n\nconst BrowserRouter = {\n  components: {\n    Router\n  },\n\n  props: {\n    history: Object,\n    basename: String,\n    forceRefresh: Boolean,\n    keyLength: Number,\n    getUserConfirmation: Function\n  },\n\n  data() {\n    let history = this.history;\n    if (!history) {\n      history = createHistory({\n        basename: this.basename,\n        forceRefresh: this.forceRefresh,\n        getUserConfirmation: this.getUserConfirmation,\n        keyLength: this.keyLength\n      });\n    }\n\n    return {\n      childHistory: history\n    }\n  }\n}\n\nexport default BrowserRouter;\n</script>","<template>\n  <router v-bind=\"childProps\">\n    <slot></slot>\n  </router>\n</template>\n\n<script>\nimport { warning } from '../util/utils';\nimport { createLocation, createPath } from \"history\";\nimport Router from \"./Router.vue\";\n\nconst addLeadingSlash = path => {\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\n};\n\nconst addBasename = (basename, location) => {\n  if (!basename) return location;\n\n  return {\n    ...location,\n    pathname: addLeadingSlash(basename) + location.pathname\n  };\n};\n\nconst stripBasename = (basename, location) => {\n  if (!basename) return location;\n\n  const base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return {\n    ...location,\n    pathname: location.pathname.substr(base.length)\n  };\n};\n\nconst createURL = location =>\n  typeof location === \"string\" ? location : createPath(location);\n\nconst staticHandler = methodName => () => {\n  throw new Error(`You cannot ${methodName} with <StaticRouter>`);\n};\n\nconst noop = () => {};\n\nconst StaticRouter = {\n  components: {\n    Router\n  },\n  \n  props: {\n    // just use to check if user pass history\n    history: {\n      validator: function (value) {\n        return true;\n      }\n    },\n\n    basename: {\n      type: 'String',\n      default: '' \n    },\n    context: {\n      type: Object,\n      default() {\n        return {};\n      }\n    },\n    location: {\n      type: [String, Object],\n      default: '/'\n    }\n  },\n\n  provide() {\n    return {\n      router: {\n        staticContext: this.context\n      }\n    };\n  },\n\n  computed: {\n    childProps() {\n      let { basename, context, location } = this;\n\n      const history = {\n        action: \"POP\",\n        location: stripBasename(basename, createLocation(location)),\n        go: staticHandler(\"go\"),\n        goBack: staticHandler(\"goBack\"),\n        goForward: staticHandler(\"goForward\"),\n        createHref: (...rest) => this.createHref(...rest),\n        push: (...rest) => this.handlePush(...rest),\n        replace: (...rest) => this.handleReplace(...rest), \n        listen: () => noop,\n        block: () => noop\n      };\n\n      return { history };\n    }\n  },\n\n  methods: {\n    createHref(path) {\n      return addLeadingSlash(this.basename + createURL(path));\n    },\n    handlePush(location) {\n      const { basename, context } = this;\n      context.action = \"PUSH\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    },\n    handleReplace(location) {\n      const { basename, context } = this;\n      context.action = \"REPLACE\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }\n  },\n\n  beforeMount() {\n    if (this.history) {\n      warning(\n        '<StaticRouter> ignores the history prop. To use a custom history, ' +\n        'use `import { Router }` instead of `import { StaticRouter as Router }`.'\n      )\n    }\n  }\n}\n\nexport default StaticRouter;\n</script>","import pathToRegexp from \"path-to-regexp\";\n\nconst patternCache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nconst compilePath = (pattern, options) => {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  const keys = [];\n  const re = pathToRegexp(pattern, keys, options);\n  const compiledPattern = { re, keys };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nconst matchPath = (pathname, options = {}, parent) => {\n  if (typeof options === \"string\") options = { path: options };\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  if (path == null) return parent;\n\n  const { re, keys } = compilePath(path, { end: exact, strict, sensitive });\n  const match = re.exec(pathname);\n\n  if (!match) return null;\n\n  const [url, ...values] = match;\n  const isExact = pathname === url;\n\n  if (exact && !isExact) return null;\n\n  return {\n    path, // the path pattern used to match\n    url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n    isExact, // whether or not we matched exactly\n    params: keys.reduce((memo, key, index) => {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\nexport default matchPath;","<template>\n  <single v-if=\"match\">\n    <component v-if=\"component\" :is=\"component\" v-bind=\"childProps\"></component>\n    <slot v-bind=\"childProps\"></slot>\n  </single>\n</template>\n\n<script>\nimport { warning } from '../util/utils';\nimport matchPath from '../util/matchPath';\nimport Single from '../util/Single';\n\nconst Route = {\n  props: {\n    path: String,\n    exact: Boolean,\n    strict: Boolean,\n    sensitive: Boolean,\n    location: Object,\n    component: Object,\n  },\n\n  inject: ['router'],\n\n  provide() {\n    return {\n      router: {\n        history: this.router.history,\n        route: {\n          location: this.location || this.router.route.location,\n          match: this.match,\n        },\n      },\n    };\n  },\n\n  computed: {\n    match() {\n      let { location, path, strict, exact, sensitive, router } = this;\n\n      if (!router) {\n        throw new Error(\n          `You should not use <Route> or withRouter() outside a <Router>`,\n        );\n      }\n\n      const { route } = router;\n      const pathname = (location || route.location).pathname;\n\n      return matchPath(\n        pathname,\n        { path, strict, exact, sensitive },\n        route.match,\n      );\n    },\n\n    childProps() {\n      let { location, match } = this;\n      const { history, route, staticContext } = this.router;\n      const nLocation = this.location || route.location;\n\n      return {\n        ...this.$attrs,\n        match,\n        location: nLocation,\n        history,\n        staticContext,\n      };\n    },\n  },\n};\n\nexport default Route;\n</script>\n","/**\n * Used for conditional rendering in template. \n */\nconst Empty = {\n  render(h) {\n    return null;\n  }\n}\n\nexport default Empty;","<template>\n  <empty></empty>\n</template>\n\n<script>\nimport { warning } from '../util/utils';\nimport Empty from '../util/empty';\n\nconst Prompt = {\n  components: {\n    Empty\n  },\n\n  props: {\n    when: {\n      type: Boolean,\n      default: true\n    },\n    message: {\n      type: [Function, String],\n      required: true\n    }\n  },\n\n  inject: ['router'],\n\n  beforeMount() {\n    if (!this.router) {\n      warning('You should not use <Prompt> outside a <Router>');\n    }\n\n    if(this.when) this.enable(this.message);\n  },\n\n  watch: {\n    when(val, old) {\n      if (val) {\n        if (!old && this.message)\n          this.enable(this.message);\n      } else {\n        this.disable();\n      }\n    },\n    message(val) {\n      if (val) {\n        this.enable(this.message);\n      }\n    }\n  },\n\n  methods: {\n    enable(message) {\n      if (this.unblock) this.unblock();\n      this.unblock = this.router.history.block(message);\n    },\n\n    disable() {\n      if (this.unblock) {\n        this.unblock();\n        this.unblock = null;\n      }\n    }\n  },\n\n  beforeDestroy() {\n    this.disable();\n  }\n}\n\nexport default Prompt;\n</script>","import pathToRegexp from \"path-to-regexp\";\n\nconst patternCache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nconst compileGenerator = pattern => {\n  const cacheKey = pattern;\n  const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  const compiledGenerator = pathToRegexp.compile(pattern);\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledGenerator;\n    cacheCount++;\n  }\n\n  return compiledGenerator;\n};\n\n/**\n * Public API for generating a URL pathname from a pattern and parameters.\n */\nconst generatePath = (pattern = \"/\", params = {}) => {\n  if (pattern === \"/\") {\n    return pattern;\n  }\n  const generator = compileGenerator(pattern);\n  return generator(params);\n};\n\nexport default generatePath;","<template>\n  <empty></empty>\n</template>\n\n<script>\nimport { createLocation, locationsAreEqual } from \"history\";\nimport { warning } from '../util/utils';\nimport generatePath from \"../util/generatePath\";\nimport Empty from '../util/empty';\n\nconst Redirect = {\n  components: {\n    Empty\n  },\n\n  props: {\n    computedMatch: Object,\n    push: {\n      type: Boolean,\n      default: false\n    },\n    from: String,\n    to: {\n      type: [String, Object],\n      required: true\n    }\n  },\n\n  inject: ['router'],\n\n  created() {\n    if (!this.router) {\n      warning('You should not use <Redirect> outside a <Router>');\n    }\n\n    this.lastTo = this.to;\n    if (this.isStatic()) this.perform();\n  },\n\n  mounted() {\n    if (!this.isStatic()) this.perform();\n  },\n\n  updated() {\n    const prevTo = createLocation(this.lastTo);\n    const nextTo = createLocation(this.to);\n\n    if (locationsAreEqual(prevTo, nextTo)) {\n      warning(\n        `You tried to redirect to the same route you're currently on: ` +\n        `\"${nextTo.pathname}${nextTo.search}\"`\n      );\n      return;\n    }\n\n    this.perform();\n  },\n\n  methods: {\n    isStatic() {\n      return this.router && this.router.staticContext;\n    },\n\n    computeTo({ computedMatch, to }) {\n      if (computedMatch) {\n        if (typeof to === \"string\") {\n          return generatePath(to, computedMatch.params);\n        } else {\n          return {\n            ...to,\n            pathname: generatePath(to.pathname, computedMatch.params)\n          };\n        }\n      }\n  \n      return to;\n    },\n\n    perform() {\n      const { history } = this.router;\n      const push = this.push;\n      const to = this.computeTo({\n        computedMatch: this.computedMatch,\n        to: this.to\n      });\n      \n      this.lastTo = this.to;\n      if (push) {\n        history.push(to);\n      } else {\n        history.replace(to);\n      }\n    }\n  }\n}\n\nexport default Redirect;\n</script>","/**\n * custom tag element\n */\nconst Tag = {\n  functional: true,\n  render(h, context) {\n    return h(context.props.tag || 'div', context.data, context.children);\n  }\n}\n\nexport default Tag;","<template>\n  <single>\n    <slot :href=\"href\" :history=\"router.history\"></slot>\n    \n    <tag \n      :tag=\"tag\" \n      :class=\"className\" \n      :style=\"style\" \n      :target=\"target\" \n      :href=\"href\"\n      v-bind=\"$attrs\"\n      @click=\"handleClick\"\n    >\n      <slot></slot>\n    </tag>\n  </single>\n</template>\n\n<script>\nimport { warning } from '../util/utils';\nimport { createLocation } from \"history\";\nimport Tag from '../util/Tag';\nimport Single from '../util/Single';\n\nconst isModifiedEvent = event =>\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nconst Link = {\n  components: {\n    Tag\n  },\n\n  props: {\n    // to path\n    to: {\n      type: [String, Object],\n      required: true\n    },\n\n    // below props not used for slot scope\n    target: String,\n    replace: {\n      type: Boolean,\n      default: false\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    className: {\n      type: [String, Object, Array],\n      default: () => {}\n    },\n    style: {\n      type: [String, Object, Array],\n      default: () => {}\n    }\n  },\n\n  inject: ['router'],\n\n  computed: {\n    href() {\n      const { history } = this.router;\n      const location =\n        typeof to === \"string\"\n          ? createLocation(to, null, null, history.location)\n          : to;\n      const href = history.createHref(location);\n\n      return href;\n    }\n  },\n\n  methods: {\n    handleClick(event) {\n      this.$emit('click', event);\n  \n      event.preventDefault();\n  \n      const { history } = this.router;\n      const { replace, to } = this;\n\n      if (replace) {\n        history.replace(to);\n      } else {\n        history.push(to);\n      }\n    }\n  },\n\n  beforeMount() {\n    if (!this.to) {\n      throw new Error('You must specify the \"to\" property');\n    }\n\n    if (!this.router) {\n      warning('You should not use <Link> outside a <Router>');\n    }\n  }\n}\n\nexport default Link;\n</script>","\n<template>\n  <route :path=\"path\" >\n    <template slot-scope=\"scope\">\n      <x-link :class=\"getClassName(scope)\">\n\n      </x-link>\n    </template>\n  </route>\n</template>\n\n<script>\nimport { warning } from '../util/utils';\nimport Route from './Route.vue';\nimport Link from './Link.vue';\n\nconst NavLink = {\n  components: {\n    Route,\n    XLink: Link\n  },\n\n  props: {\n    // to path\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    path: {\n      type: String,\n      required: true\n    },\n\n    activeClass: String,\n    activeStyle: Object\n  },\n\n  methods: {\n    getClassName({ match }) {\n      return match ? this.activeClass : '';\n    },\n    getStyle({ match }) {\n      return match ? this.activeStyle : {};\n    }\n  }\n}\n\nexport default NavLink;\n</script>","import { warning } from './utils';\nimport matchPath from \"./matchPath\";\n\n/**\n * render the first matched Route\n */\nconst Switch = {\n  props: {\n    location: Object\n  },\n\n  inject: ['router'],\n\n  beforeMount() {\n    if (!this.router) {\n      warning('You should not use <Switch> outside a <Router>');\n    }\n  },\n\n  render(h) {\n    const vnode = this.$slots.default.find(vnode => {\n      if (!vnode.componentOptions) return false;\n      const { path, exact, strict, sensitive } = vnode.componentOptions.propsData;\n      return matchPath(path, { exact, strict, sensitive }, this.router.location)\n    });\n    return vnode;\n  }\n}\n\nexport default Switch;","import Route from \"../component/Route.vue\";\n\n/**\n * wrap Component with Route, \n * so the Component will have the propeties: location, history, match ...\n */\nconst withRouter = Component => {\n  return {\n    functional: true,\n    render(h, context) {\n      context.data.props.component = Component;\n      return h(Route, context.data, context.children);\n    }\n  }\n}\n\nexport default withRouter;"],"names":["warning","message","console","warn","copyJson","data","JSON","parse","stringify","Single","functional","render","h","context","children","length","props","name","patternCache","cacheLimit","cacheCount","compilePath","pattern","options","cacheKey","end","strict","sensitive","cache","keys","re","pathToRegexp","compiledPattern","matchPath","pathname","parent","path","exact","match","exec","url","values","isExact","params","reduce","memo","key","index","Empty","compileGenerator","compiledGenerator","compile","generatePath","generator","Tag","tag","Switch","location","Object","inject","beforeMount","router","vnode","$slots","default","find","componentOptions","propsData","withRouter","Component","component","Route"],"mappings":"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"}